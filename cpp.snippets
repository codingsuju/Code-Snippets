snippet snips "all snippets"
/*
beg
*/
endsnippet

snippet beg "template"
#ifdef ONPC
	#define _GLIBCXX_DEBUG
#endif
#include <bits/stdc++.h>
#define sz(a) ((int)((a).size()))
#define char unsigned char

using namespace std;
// mt19937 rnd(239);
mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());

typedef long long ll;
typedef long double ld;

int solve() {
	$0
	return 0;
}

int32_t main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	int TET = 1e9;
	//cin >> TET;
	for (int i = 1; i <= TET; i++) {
		if (solve()) {
			break;
		}
		#ifdef ONPC
			cout << "__________________________" << endl;
		#endif
	}
	#ifdef ONPC
		cerr << endl << "finished in " << clock() * 1.0 / CLOCKS_PER_SEC << " sec" << endl;
    #endif
}
endsnippet

snippet BinaryTrie "Binary Trie"
class Node{
public:
       int c;
       bool isLeaf;
       Node* children[2];
};
Node *getNode(int c)
{
         Node *node=new Node();
         node->c=c;
         node->isLeaf=false;
         for(int i=0;i<2;i++)
         {
             node->children[i]=NULL;
         }
         return node;
}
class Trie{
private:
    Node *root;
public:
    Trie()
    {
        root=getNode(2);
    }
    static Node *getroot(Trie &trie)
    {
        return trie.root;
    }
};
int calculate(vector<int>& nums,Trie &trie)
{   //Building trie
    for(int i=0;i<nums.size();i++)
    {
         Node *cur=trie.getroot(trie);
         for(int j=31;j>=0;j--)
         {
                int x;
                if(nums[i]&(1<<j))
                    x=1;
                else
                    x=0;
                if(cur->children[x]==NULL)
                {
                    cur->children[x]=getNode(x);
                }
                cur=cur->children[x];
         }
         cur->isLeaf=true;
    } 
    //Finding answer
    int ans=0;
    for(int i=0;i<nums.size();i++)
    {
            Node *cur=trie.getroot(trie);
            int res=0;
            for(int j=31;j>=0;j--)
            {
                int x;
                if(nums[i]&(1<<j))
                    x=1;
                else
                    x=0;
                if(cur->children[x^1])
                {
                    res=(res|(1<<j));
                    cur=cur->children[x^1];
                }
                else
                    cur=cur->children[x];
            }
            ans=max(ans,res);
     }
     return ans;                                                                                          
}    
endsnippet 

snippet BinomialCoefficients "Binomial Coefficients"
#define ll long long 
const int MAX_N=1e6;
const int MOD=1e9+7;
const int INF=1e9;
const ll LINF=1e18;
const int choose_k=4;
long long int C[MAX_N][choose_k];
void precompute()
{
  for(int i=0;i<MAX_N;i++)
  {
      C[i][0]=1;
      if(i<choose_k)
      {
          C[i][i]=1;
      }
      for(int j=1;j<i && j<choose_k;j++)
      {
          C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;
      }
  }
  cout<<C[5][3];
}            
endsnippet

snippet FactorsAndDivisors "Factors and Divisors"
void factors(int x,vector<int> &fac,unordered_map<int,int> &f)
{
    int n=x;
    for(int i=2;i*i<=n;i++)
    {
        while(x%i==0)
        {
            if(f[i]==0)
            fac.push_back(i);
            f[i]++;
            x/=i;
        }
        if(x==1)
            break;
    }
    if(x!=1)
    {
        fac.push_back(x);
        f[x]++;
    }
}
void divisors(int x,int pos,int res,vector<int> &fac,vector<int> &div,unordered_map<int,int> &f)
{
     if(pos==(int)fac.size()){
        div.push_back(res);
        return;
     }
     for(int i=0;i<=f[fac[pos]];i++)
     {
        divisors(x,pos+1,res,fac,div,f);
        res*=fac[pos];
     }
}
//Calling function
void solve()
{
   int x;
   cin>>x;
   vector<int> fac;
   unordered_map<int,int> f;
   factors(x,fac,f);
   vector<int> div;
   divisors(x,0,1,fac,div,f);
   for(int s:fac)
    cout<<s<<" ";
   cout<<"\n";
   for(int s:div)
    cout<<s<<" ";
   cout<<"\n";
   vector<int> sum=sum_of_divisors(100);
   for(int d:sum)
    cout<<d<<" ";
}
endsnippet

snippet SumOfDivisors "Sum of Divisors"
vector<int> sum_of_divisors(int N)
{
    vector<int> sum(N,0);
    vector<int> d(N,-1);
    d[1]=1;
    for(int i=2;i*i<N;i++)
    {
        if(d[i]==-1)
        {
            d[i]=i;
            for(int j=i*i;j<N;j+=i)
            {
                if(d[j]==-1)
                    d[j]=i;
            }
        }
    }
    sum[1]=1;
    for(int i=2;i<N;i++)
    {
        if(d[i]==-1)
        {
            d[i]=i;
            sum[i]=i+1;
        }
        else
        {
            int j=i;
            sum[i]=1;
            while(j%d[i]==0)
            {
                j/=d[i];
                sum[i]=sum[i]*d[i]+1;
            }
            sum[i]*=sum[j];
        }
    }
    return sum;
}
endsnippet

snippet lcm_gcd "LCM and GCD"
 vector<long long int> LCM(43);

long long gcd(long long int a, long long int b)
{
  if (b == 0)
    return a;
  return gcd(b, a % b);
}
long long lcm(long long int a, long long int b)
{
    return (a / gcd(a, b)) * b;
}
//Function call
void solve(){
    LCM[1]=1;
    for(int i=2;i<43;i++)
    {
       LCM[i]=lcm(LCM[i-1],i);
    }
}
endsnippet

snippet ModularInverse "Modular Inverse"
 int power(int x, int y, int m) {

   if (y == 0)
      return 1;
   int p = power(x, y / 2, m) % m;
   p = (int)((p * (long long int )p) % m);
   if (y % 2 == 0)
      return p;
   else
      return (int)((x * (long long int)p) % m);
}
int modInverse(int a, int m) {
        return power(a, m - 2, m);
}
//Function call
void solve()
{
     int x=modInverse(5,MOD);
     cout<<x<<"\n";
}
endsnippet

snippet SOE "Sieve of Eratosthenes"
void solve()

{
   int n;
   cin>>n;
   vector<bool> prime(n+1);
   for(int i=0;i<n;i++)prime[i]=true;
   prime[0]=false,prime[1]=false;
   for(int i=2;i*i<=n;i++)
   {
      if(prime[i]==true)
      for(int j=i*i;j<=n;j+=i)prime[j]=false;
   }
   for(int i=2;i<=n;i++)
   {
     if(prime[i]==true)
        cout<<i<<" ";
   }
}
endsnippet

snippet Bitmask "Bitmasking"
#define ll long long 
const int MAX_N=2e5+1;
const int MOD=1e9+7;
const int INF=1e9;
const ll LINF=1e18;
int x=10;
int dp[MAX_N][100];
int calculate(int mask,vector<int> &value,int n,int cur)
{
    if(mask==(1<<n)-1)
    {
       return 1; 
    }
    else if(dp[mask][cur]!=-1)
        return dp[mask][cur];
    int ans=n+1;
    for(int i=0;i<n;i++)
    {
        if(!(mask&(1<<i)))
        {  
           if(cur+value[i]<=x)
           ans=min(ans,calculate(mask^(1<<i),value,n,cur+value[i]));
           else
           ans=min(ans,calculate(mask^(1<<i),value,n,value[i])+1); 
        }
    }
    return dp[mask][cur]=ans;
}
void solve()
{
   vector<int> value{2,3,3,5,6,7,4,8,10};
   int n=value.size();
   int mask=0;
   memset(dp,-1,sizeof dp);
   int ans=calculate(0,value,n,0);
   cout<<ans<<"\n";
}
endsnippet

snippet DFSin2D "DFS in 2D"
//Class Definition and Basic function:
const int INF=1e9;
class Point{
public:
    int x;
    int y;
    Point(int X,int Y){
        x=X;
        y=Y;
    }
};
class Matrix{
public:
    vector<Point> adj;
};
vector<vector<Matrix>> matrix; // Global class Variable
void set_vis_false(vector<vector<bool>> &vis)
{
   for(int i=0;i<vis.size();i++){
       for(int j=0;j<vis[0].size();j++){
          vis[i][j]=false;
       }
   }
}
bool is_valid(int x,int y,int m,int n)
{
   if(x<0 || y<0 ||x>=m ||y>=n)
      return false;
   return true;
}
//Checking if path exist:
bool dfs(Point s,Point &d,vector<vector<bool>> &vis)
{
   vis[s.x][s.y]=true;
   if(s.x==d.x && s.y==d.y)return true;
   bool ans=false;
   for(Point &P:matrix[s.x][s.y].adj)
   {
      if(vis[P.x][P.y]==false)
      {
        ans=(ans||dfs(P,d,vis));
      }
   }
   return ans;
}
//Shortest path:
int min_dfs(Point s,Point &d,vector<vector<bool>> &vis,vector<vector<int>> &min_dp)
{  
   if(s.x==d.x && s.y==d.y)return 0;
   else if(vis[s.x][s.y]==true)
      return min_dp[s.x][s.y];
   vis[s.x][s.y]=true;
   int ans=INF;
   for(Point P:matrix[s.x][s.y].adj)
   {
     ans=min(ans,min_dfs(P,d,vis,min_dp)+1);
   }  
   return min_dp[s.x][s.y]=ans;
}
//Longest path without visiting node twice:
int max_dfs(Point s,Point &d,vector<vector<bool>> &vis)
{  
   if(s.x==d.x && s.y==d.y)
      return 0;
   else if(vis[s.x][s.y]==true)
      return INT_MIN;
   vis[s.x][s.y]=true;
   int ans=INT_MIN;
   for(Point &P:matrix[s.x][s.y].adj)
   {
      ans=max(ans,max_dfs(P,d,vis)+1);
   }
   vis[s.x][s.y]=false;  
   return ans;
}
//Function call:
void solve()
{
     int m=4,n=4;
     vector<vector<Matrix>> matrix_dup(m,vector<Matrix>(n));
     matrix=matrix_dup;
     for(int i=0;i<m;i++)
     {
      for(int j=0;j<n;j++)
      {
         if(is_valid(i+1,j,m,n)==true)
            matrix[i][j].adj.push_back(Point(i+1,j));  //Down
         if(is_valid(i,j+1,m,n)==true)
           matrix[i][j].adj.push_back(Point(i,j+1));   //Right
         if(is_valid(i-1,j,m,n)==true)
           matrix[i][j].adj.push_back(Point(i-1,j));   //Up
         if(is_valid(i,j-1,m,n)==true)
           matrix[i][j].adj.push_back(Point(i,j-1));   //Left
      }
     }
     vector<vector<bool>> vis(m,vector<bool>(n));
     Point s=Point(0,0);
     Point d=Point(2,2);
     
     set_vis_false(vis);
     cout<<(dfs(s,d,vis)==true?"YES":"NO");
 
     set_vis_false(vis);
     vector<vector<int>> min_dp(m,vector<int> (n,INF));
     cout<<"\n"<<min_dfs(s,d,vis,min_dp);
 
     set_vis_false(vis); 
     cout<<"\n"<<max_dfs(s,d,vis); //cannot visit node twice
}
endsnippet

snippet Trie "Trie Data Structure"
//Implementation:
class Node{
    public:
       char c;
       bool isWord;
       int Count;
       int terminating;
       Node* children[26];
};
Node *getNode(char c)
        {
         Node *node=new Node();
         node->c=c;
         node->Count=0;
         node->terminating=0;
         node->isWord=false;
         for(int i=0;i<26;i++)
         {
             node->children[i]=NULL;
         }
         return node;
       }
class Trie{
private:
    Node *root;
public:
    Trie()
    {
        root=getNode('\0');
    }
    void insert(string &word)
    {
        Node *curr=root;
        for(int i=0;i<word.size();i++)
        {
            char c=word[i];
            if(curr->children[c-'a']==NULL)
                curr->children[c-'a']=getNode(c);
            curr=curr->children[c-'a'];
            (curr->Count)=(curr->Count)+1;
        }
        curr->terminating=curr->terminating+1;
        curr->isWord=true;
    }
    int search_count(string word)
    {
        Node *curr=root;
        for(int i=0;i<word.size();i++)
        {
           char c=word[i];
           if(curr->children[c-'a']==NULL)
             return 0;
           curr=curr->children[c-'a'];   
        }
        return curr->terminating;
    }
    int prefix_count(string str)
    {
        Node *curr=root;
        for(int i=0;i<str.size();i++)
        {
           char c=str[i];
           if(curr->children[c-'a']==NULL)
             return 0;
           curr=curr->children[c-'a'];   
        }
        return curr->Count;
    }
    void construct_trie(vector<string> & words)
    {
        for(string &word:words)
        {
            insert(word);
        }
    }
    long long int calculate(string &word,string &a,int k)
    {
        long long int ans=0;
        for(int i=0;i<word.size();i++)
        {
           int t=0;
           Node *curr=root;
           for(int j=i;j<word.size();j++)
           {
              char c=word[j];
              if(a[c-'a']=='0')
                t++;
              if(t>k)
                break;
              if(curr->children[c-'a']==NULL){
                  curr->children[c-'a']=getNode(c);
                  ans++;
              }
              curr=curr->children[c-'a'];
              (curr->Count)=(curr->Count)+1;
           }
           curr->terminating=curr->terminating+1;
           curr->isWord=true;
       }
       return ans;
    }
};
//Function call
void solve()
{
   Trie trie;
   string s;
   cin>>s;
   int n=26;
   string a;
   cin>>a;
   int k;
   cin>>k;
   long long int  ans=trie.calculate(s,a,k);
   cout<<ans<<"\n";
}
endsnippet
