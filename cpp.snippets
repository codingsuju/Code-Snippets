snippet snips "all snippets"
/*
beg
*/
endsnippet

snippet beg "template"
#ifdef ONPC
	#define _GLIBCXX_DEBUG
#endif
#include <bits/stdc++.h>
#define sz(a) ((int)((a).size()))
#define char unsigned char

using namespace std;
// mt19937 rnd(239);
mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());

typedef long long ll;
typedef long double ld;

int solve() {
	$0
	return 0;
}

int32_t main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	int TET = 1e9;
	//cin >> TET;
	for (int i = 1; i <= TET; i++) {
		if (solve()) {
			break;
		}
		#ifdef ONPC
			cout << "__________________________" << endl;
		#endif
	}
	#ifdef ONPC
		cerr << endl << "finished in " << clock() * 1.0 / CLOCKS_PER_SEC << " sec" << endl;
	#endif
}
endsnippet

snippet BInaryTrie "Binary Trie"
class Node{
public:
       int c;
       bool isLeaf;
       Node* children[2];
};
Node *getNode(int c)
{
         Node *node=new Node();
         node->c=c;
         node->isLeaf=false;
         for(int i=0;i<2;i++)
         {
             node->children[i]=NULL;
         }
         return node;
}
class Trie{
private:
    Node *root;
public:
    Trie()
    {
        root=getNode(2);
    }
    static Node *getroot(Trie &trie)
    {
        return trie.root;
    }
};
int calculate(vector<int>& nums,Trie &trie)
{   //Building trie
    for(int i=0;i<nums.size();i++)
    {
         Node *cur=trie.getroot(trie);
         for(int j=31;j>=0;j--)
         {
                int x;
                if(nums[i]&(1<<j))
                    x=1;
                else
                    x=0;
                if(cur->children[x]==NULL)
                {
                    cur->children[x]=getNode(x);
                }
                cur=cur->children[x];
         }
         cur->isLeaf=true;
    } 
    //Finding answer
    int ans=0;
    for(int i=0;i<nums.size();i++)
    {
            Node *cur=trie.getroot(trie);
            int res=0;
            for(int j=31;j>=0;j--)
            {
                int x;
                if(nums[i]&(1<<j))
                    x=1;
                else
                    x=0;
                if(cur->children[x^1])
                {
                    res=(res|(1<<j));
                    cur=cur->children[x^1];
                }
                else
                    cur=cur->children[x];
            }
            ans=max(ans,res);
     }
     return ans;                                                                                          
 }    
endsnippet 